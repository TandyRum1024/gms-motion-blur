// 2019-07-29 04:10:15
#event create Main 3D camera
// show_debug_overlay(true);
#section Set camera
mouselock = true;
aspect = view_wview[0] / view_hview[0];
fov = 90;

z = 64; // z pos

lookH = 0; // horizontal rotation
lookV = -0.045; // vertical rotation / pitch
lookR = 0; // "side roll" rotation (think of Quake's wobbly camera when strafing)
lookHDelta = 0; // amount of lookH changed
lookRDelta = 0; // amount of lookR changed

camX = 0; // x offset for camera shake
camY = 0; // y offset for camera shake
camZ = 0; // forward offset for camera shake
camR = 0; // rotation offset for camera shake

/// storing velocity of camera (for shader)
vfwd = 0; // forward
vrh = 0; // horizontal
vrv = 0; // vetical / pitch
vrr = 0; // rotation

// and actual velocity, used to offset the camera
vx = 0;
vy = 0;
vz = 0;
vr = 0;

draw_set_alpha_test(true);
d3d_set_culling(false);
#section Set shader
time = 0;
application_surface_draw_enable(false);
motionblurEnabled = true;
motionblurStrength = 1.0;

/// Shader related stuff
texBlueNoise = sprite_get_texture(texBluenoise64, 0);

// motionblur : camera velocity [xvel, yvel, zoomvel]
shMotionblurNoise = shader_get_sampler_index(sh_motionblur_fullscreen, "sNoise");
shMotionblurVel = shader_get_uniform(sh_motionblur_fullscreen, "uVelocity");
shMotionblurStr = shader_get_uniform(sh_motionblur_fullscreen, "uStrength");
shMotionblurTime = shader_get_uniform(sh_motionblur_fullscreen, "uTime");
shMotionblurTexsize = shader_get_uniform(sh_motionblur_fullscreen, "uTexsize");
// shMotionblurTex = shader_get_sampler_index(sh_motionblur_linear, "sTex");
// shMotionblurTexinfo = shader_get_uniform(sh_motionblur_linear, "uTexinfo");

texture_set_stage(shMotionblurNoise, texBlueNoise);
#section viewmodel?
viewmodelx = 0;
viewmodely = 0;
viewmodelr = 0;
viewmodelScale = 3;

viewmodelvelr = 0;

viewmodelShakeCtr = 0; // Counter for viewmodel shaking
viewmodelShockCtr = 0; // Counter for viewmodel showing ""shocked"" face
viewmodelFacing = 0; // Viewmodel facing direction. -1 = left, 0 = forward, 1 = right
viewmodelSpr = 0;

#event step (unused) FPS physics (unused)
/*
var _axish = keyboard_check(vk_right) - keyboard_check(vk_left);
var _axisv = keyboard_check(vk_down) - keyboard_check(vk_up);
var _axisroll = keyboard_check_pressed(ord('Q')) - keyboard_check_pressed(ord('E'));
var _movesprint = keyboard_check(vk_shift);
var _movefwd = keyboard_check(ord('W')) - keyboard_check(ord('S'));
var _moveside = keyboard_check(ord('D')) - keyboard_check(ord('A'));

if (keyboard_check_pressed(vk_escape))
{
    mouselock = !mouselock;
}

// rotate
var _rotamt = 0;

if (mouselock)
{
    var _cx = window_get_width() * 0.5, _cy = window_get_height() * 0.5;
    _rotamt = (window_mouse_get_x() - _cx) * sensivity; // _axish * 4;
    window_mouse_set(_cx, _cy);
}

lookHDelta = _rotamt;
lookH += _rotamt;
lookV += _axisv * 0.1;
vrr += -_rotamt * 0.02;

if (_axisroll != 0)
    vrr += _axisroll * 20;

lookR += vrr;

// move
if (_movesprint)
    moveVel = moveRunMax;
else
    moveVel = moveMax;

if (_movefwd != 0) accerlate_quake(moveAcc, lookH + 180 * max(-_movefwd, 0));
if (_moveside != 0) accerlate_quake(moveAcc, lookH + 90 + 180 * max(-_moveside, 0));
forwardVel = dot_product(dcos(lookH), dsin(lookH), vx, vy);
//vx = (dcos(lookH) * _movefwd + dcos(lookH + 90) * _moveside) * 2;
//vy = (dsin(lookH) * _movefwd + dsin(lookH + 90) * _moveside) * 2;

var _moveDelta = point_distance(0, 0, vx, vy);
moveCtr += _moveDelta;
camZ = dsin(moveCtr * 4) * (_moveDelta / moveVel) * 5; // headbob

// update pos
x += vx;
y += vy;
z += vz;

if (_movefwd == 0 && _moveside == 0)
{
    vx *= 0.85;
    vy *= 0.85;
}
else
{
    vx *= 0.95;
    vy *= 0.95;
}

vrr += -lookR * 0.02;
vrr *= 0.9;

// Update viewmodel
var _viewmodelBob = dsin(moveCtr * 2) * (_moveDelta / moveVel);
viewmodelx = _viewmodelBob * 42; // viewmodel bob
viewmodely = abs(dcos(moveCtr * 2) * (_moveDelta / moveVel)) * -16;

viewmodelvelr += _viewmodelBob * 0.05 + _rotamt * 0.035;
viewmodelr += viewmodelvelr;
viewmodelvelr += -viewmodelr * 0.02;
viewmodelvelr *= 0.9;
*/
#section Update camera motion
// update velocity
vr -= clamp(camR * 0.05, -6.0, 6.0);
vx -= clamp(camX * 0.2, -6.0, 6.0);
vy -= clamp(camY * 0.2, -6.0, 6.0);
vz -= clamp(camZ * 0.2, -6.0, 6.0);

camR += vr;
camX += vx;
camY += vy;
camZ += vz;

vr *= 0.9;
vx *= 0.9;
vy *= 0.9;
vz *= 0.9;
#section Toggle stuff
if (keyboard_check_pressed(ord("1")))
{
    motionblurEnabled = !motionblurEnabled;
}

if (instance_exists(oPlayer) && keyboard_check_pressed(ord("2")))
{
    oPlayer.shakeEnabled = !oPlayer.shakeEnabled;
}
#section Update viewmodel
// calculate viewmodel sprite index
if (viewmodelShockCtr > 0)
{
    viewmodelShockCtr--;
    viewmodelSpr = 3;
}
else
{
    viewmodelSpr = 1 + viewmodelFacing;
}

// update viewmodel shake counter
if (viewmodelShakeCtr > 0)
    viewmodelShakeCtr--;
else
    viewmodelShakeCtr = 0;
    
// update viewmodel motion
viewmodelx = -camX * 0.5;
viewmodely = -camY * 0.5 - 32 + vfwd * 4.0;
viewmodelr = camR + lookR;
#section Tone down blur strength gradually
motionblurStrength = lerp(motionblurStrength, 1.0, 0.99);

#event draw Draw sky
var _dist = 5000;
d3d_draw_cylinder(x - _dist, y - _dist, z + _dist, x + _dist, y + _dist, z - _dist, sprite_get_texture(tex3DBG, 0), 1, 1, true, 64);
d3d_draw_floor(-6400, -6400, -4, 6400, 6400, -4, sprite_get_texture(texFloor, 1), 200, 200);

#event draw_begin Set projection
var _lookcos = dcos(lookH);
var _looksin = dsin(lookH);
var _lookcos2 = dcos(lookH + 90);
var _looksin2 = dsin(lookH + 90);

var _targetx = x + _lookcos, _targety = y + _looksin, _targetz = z + lookV;
var _rollx = 0, _rolly = 1 * dsin(lookR + camR), _rollz = 1 * dcos(lookR + camR);
var _xup = _rollx * _lookcos - _rolly * _looksin;
var _yup = _rollx * _looksin + _rolly * _lookcos;
var _zup = _rollz;

var _xoff = camX * _lookcos2 - camY * _looksin2;
var _yoff = camX * _looksin2 + camY * _lookcos2;

d3d_start();
d3d_set_projection_ext(x + _xoff, y + _yoff, z + camZ, _targetx + _xoff, _targety + _yoff, _targetz + camZ, _xup, _yup, _zup, fov, aspect, 0.1, 6666);
//d3d_set_projection_ext(x, y, z, _targetx, _targety, _targetz, _rollx, _rolly, _rollz, fov, aspect, 0.01, 6666);
/*
var _pmat;
var _lookmat = matrix_build(0,0,0, lookV, lookH, lookR, 1,1,1);
var _lookmat = matrix_build(0,0,0, lookV, lookH, lookR, 1,1,1);

matrix_set(matrix_projection, _pmat);
*/

#event draw_end draw end
d3d_end();
d3d_set_projection_ortho(0,0,window_get_width(),window_get_height(),0);

#event draw_post (MOTION BLUR) Draw post processed appsurf

if (motionblurEnabled)
{
    // Draw screen pass with motion blur (with interpolation on)
    texture_set_interpolation(true);
    shader_set(sh_motionblur_fullscreen);
    
    // surface size / texture size
    shader_set_uniform_f(shMotionblurTexsize, surface_get_width(application_surface), surface_get_height(application_surface));
    
    // blur info
    time++;
    shader_set_uniform_f(shMotionblurTime, time * 0.1);
    
    // remap the velocity so that subtle movements doesn't make a lot of blur
    var _vf = min(max(0, abs(vfwd) - 4.0) / 16.0, 1.0);
    
    shader_set_uniform_f(shMotionblurVel, vrh + vx, vrv + vz, _vf, -vrr - vr); // set camera velocities
    shader_set_uniform_f(shMotionblurStr, 1.0 * motionblurStrength, max(0.4, 0.5 * motionblurStrength), 2.0 * motionblurStrength); // set motion blur strength
    
    // draw screen pass
    draw_surface(application_surface, 0, 0);
    shader_reset();
    texture_set_interpolation(false);
}
else
{
    draw_surface(application_surface, 0, 0);
}
#section viewmodel / HUD
var _hudx = window_get_width() >> 1, _hudy = window_get_height() - 21;
var _drawx = _hudx + viewmodelx + random_range(-viewmodelShakeCtr, viewmodelShakeCtr), _drawy = _hudy + viewmodely + random_range(-viewmodelShakeCtr, viewmodelShakeCtr);
var _drawr = viewmodelr + random_range(-viewmodelShakeCtr, viewmodelShakeCtr) * 0.8;

var _colour = make_colour_hsv(time * 2.0, 255, 255); // rainbow colour

/// Sprite
draw_sprite_ext(sprViewThanno, viewmodelSpr, _drawx, _drawy, viewmodelScale, viewmodelScale, _drawr, c_white, 1);

/// Text
// calculate metre per second
var _metreperframe = vfwd / 8;
var _mph = _metreperframe * 26.8224;
var _hudstr = string(_mph) + " MPH";
var _strscale = viewmodelScale * 0.5;
var _viewmodelOffx = 21 * viewmodelScale;

draw_set_halign(0); draw_set_valign(2);
draw_set_font(fntComicSans);
draw_text_transformed_colour(_drawx + _viewmodelOffx + 2, _drawy, _hudstr, _strscale, _strscale, _drawr, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(_drawx + _viewmodelOffx, _drawy, _hudstr, _strscale, _strscale, _drawr, _colour, _colour, _colour, _colour, 1.0);
draw_set_font(fntDefault);
draw_set_halign(0); draw_set_valign(0);
#section Draw FPS counter & info
var _wid = window_get_width() - 10;
var _infoy = 10, _infostr = "FPS : " + string(fps_real), _infocol = c_yellow;

// draw fps
draw_set_font(fntDefault);
// draw_text_colour(10 + 2, _infoy + 2, _infostr, c_black, c_black, c_black, c_black, 1.0);
// draw_text_colour(10, _infoy, _infostr, _infocol, _infocol, _infocol, _infocol, 1.0);

// draw info
_infoy += 30;
if (motionblurEnabled)
{
    _infostr = "Press [1] to toggle Motion blur! (Blur : ON)";
    _infocol = c_lime;
}
else
{
    _infostr = "Press [1] to toggle Motion blur! (Blur : OFF)";
    _infocol = c_yellow;
}
draw_text_transformed_colour(10 + 2, _infoy + 2, _infostr, 0.8, 0.8, 0, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(10, _infoy, _infostr, 0.8, 0.8, 0, _infocol, _infocol, _infocol, _infocol, 1.0);

_infoy += 30;
if (instance_exists(oPlayer) && oPlayer.shakeEnabled)
{
    _infostr = "Press [2] to toggle Camera shake (Shake : ON)";
    _infocol = c_lime;
}
else
{
    _infostr = "Press [2] to toggle Camera shake (Shake : OFF)";
    _infocol = c_yellow;
}
// draw_text_transformed_colour(10 + 2, _infoy + 2, _infostr, 0.8, 0.8, 0, c_black, c_black, c_black, c_black, 1.0);
// draw_text_transformed_colour(10, _infoy, _infostr, 0.8, 0.8, 0, _infocol, _infocol, _infocol, _infocol, 1.0);