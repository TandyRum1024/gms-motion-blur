<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayer</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Controllable player
// (don't mind about the object name, It was a placeholder name but I'd keep it as is k thanks)
// set mask &amp; sprite attributes
mask_index = sprMask16;
sprite_index = sprPlayer;
image_speed = 0;

// velocities
vx = 0;
vy = 0;
accel = 0.5;
velMax = 6;

// frames elapsed
time = 0;

// rendering attributes
enum ePLRANIM
{
    IDLE = 0,
    MOVE,
    SHOOT,
    DEAD
}
animInit = false;
animTime = 0; // "local" animation time for animation timing
animState = ePLRANIM.IDLE; // current animation state
facingH = 1; // horizontal facing
facingV = 1; // vertical facing

lastMoveH = 1;
lastMoveV = 0;

animOffX = 0; // sprite attributes for animation
animOffY = 0;
animOffZ = 16;
animOffAngle = 0;
animXScale = 1;
animYScale = 1;

// attack timer
shootCtr = 0;
shootCtrMax = room_speed * 0.2;
quipCtr = 0;
quipCtrMax = room_speed;

// quip to draw while shooting stuff
quips = -1;
quips[0] = "BULLET";
quips[1] = "FIRE";
quips[2] = "pew";
quips[3] = "*bullet noises*";
quips[4] = "SCHÃœT";
quips[5] = "please";
quipCurrent = "";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Physics &amp; movement
// Movement
// prevent moving if menu is currently shown
if (instance_exists(oKNT_2DDEMO) &amp;&amp; oKNT_2DDEMO.iui_kbFocusItem == -1)
{
    var _h = keyboard_check(vk_right) - keyboard_check(vk_left);
    var _v = keyboard_check(vk_down) - keyboard_check(vk_up);
}
else
{
    var _h = 0;
    var _v = 0;
}

if (_h != 0)
{
    var _velDelta = min(velMax - vx * _h, accel);
    vx += _velDelta * _h;
    
    facingV = 1;
    facingH = _h;
    
    lastMoveV = 0;
    lastMoveH = _h;
}
if (_v != 0)
{
    var _velDelta = min(velMax - vy * _v, accel);
    vy += _velDelta * _v;
    
    facingV = _v;
    
    lastMoveH = 0;
    lastMoveV = _v;
}

// Collision - horizontal
var _sv = sign(vx), _ctr = 0;
if (place_meeting(x + vx, y, oBLOCK))
{
    while (!place_meeting(x + _sv, y, oBLOCK) &amp;&amp; _ctr++ &lt; 24)
        x += _sv;
    
    if (_ctr &gt;= 24)
    {
        while (place_meeting(x, y, oBLOCK) &amp;&amp; _ctr-- &gt; 0)
            x -= _sv;
    }
    
    vx = 0;
}
x += vx;

// Collision - vertical
_sv = sign(vy); _ctr = 0;
if (place_meeting(x, y + vy, oBLOCK))
{
    while (!place_meeting(x, y + _sv, oBLOCK) &amp;&amp; _ctr++ &lt; 24)
        y += _sv;
    
    if (_ctr &gt;= 24)
    {
        while (place_meeting(x, y, oBLOCK) &amp;&amp; _ctr-- &gt; 0)
            y -= _sv;
    }
    
    vy = 0;
}
y += vy;

// sort depth
depth = -y;

// damp velocities
if (_h == 0)
    vx *= 0.95;
if (_v == 0)
    vy *= 0.95;

// Let hell loose by pressing Z
if (keyboard_check_pressed(ord('Z')) &amp;&amp; shootCtr == 0)
{
    animation_set(ePLRANIM.SHOOT);

    shootCtr = shootCtrMax;
    quipCtr = quipCtrMax;
    
    if (instance_exists(oKNT_2DDEMO))
    {
        oKNT_2DDEMO.camVr += random_range(-8, 8);
        oKNT_2DDEMO.camVx += random_range(-4, 4);
        oKNT_2DDEMO.camVy += random_range(-4, 4);
        oKNT_2DDEMO.camVz += random_range(-0.2, 0.1);
    }
    
    // shoot
    instance_create(x, y, oOWOZONE);
    var _i = instance_create(x, y, oProjectile);
    _i.z = -8;
    
    _i.vx = lastMoveH * random_range(3, 6);
    _i.vy = lastMoveV * random_range(3, 6);
    _i.vz = random_range(-5, -7);
    
    // quip
    quipCurrent = quips[irandom_range(0, array_length_1d(quips) - 1)];
}

if (shootCtr &gt; 0)
    shootCtr--;
if (quipCtr &gt; 0)
    quipCtr--;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Calculate animation
time++;
var _velmagnitude = point_distance(0, 0, vx, vy);

switch (animState)
{
    case ePLRANIM.MOVE:
        /// First frame routine
        if (!animInit)
        {
            animInit = true;
            animTime = 0;
            animation_set_vars(0, 0, 0, 1, 1);
            
            image_index = 0;
        }
        
        /// Update animation conditions
        if (_velmagnitude &lt; 1)
        {
            animation_set(ePLRANIM.IDLE);
        }

        /// Animate
        var _boingperstep = (pi * 2) / (velMax * 30); // make 1 sin cycle per 30 frames of max velocity movement (2pi = 1 full cycle)
        var _boingamplitude = 8.0; // how many pixels to bounce upwards
        animTime += _velmagnitude * _boingperstep;

        // sin() gives you an wavy motion, abs(sin()) gives you a bouncy motion, with 2 bounces per cycle
        animOffZ = power(abs(sin(animTime)), 3) * -_boingamplitude * min(abs(vx), 1.0);
        animOffAngle = sin(animTime * 2) * 8;
        image_index = round(sin(animTime) + 1);
        
        if (facingV) sprite_index = sprPlayer;
        else sprite_index = sprPlayerBack;
        image_xscale = facingH;
        break;

    case ePLRANIM.SHOOT:
        /// First frame routine
        if (!animInit)
        {
            animInit = true;
            animTime = 0;
            animation_set_vars(0, 0, 0, 1, 1);
            
            image_index = 3;
        }
        
        /// Update animation conditions
        var _locallerp, _sectiondiv = 2, _sectiondiv2 = 15, _sectiondiv3 = 20;
        animTime++;
        
        if (animTime &lt;= _sectiondiv)
        {
            _locallerp = power(min(animTime / _sectiondiv, 1.0), 2);
            animOffX = lerp(1, -8, _locallerp) * facingH;
            animOffY = lerp(1, -2, _locallerp);
            animOffAngle = lerp(-4, 45, _locallerp) * facingH;
        }
        else if (animTime &lt;= _sectiondiv2)
        {
            _locallerp = power(clamp((animTime - _sectiondiv - 1) / (_sectiondiv2 - _sectiondiv - 1), 0.0, 1.0), 2);
            //animOffX = lerp(-8, 2, _locallerp) * facingH;
            //animOffY = lerp(-2, -16, _locallerp);
            animOffAngle = lerp(45, -10, _locallerp) * facingH;
        }
        else if (animTime &lt;= _sectiondiv3)
        {
            _locallerp = power(clamp((animTime - _sectiondiv2 - 1) / (_sectiondiv3 - _sectiondiv2 - 1), 0.0, 1.0), 2);
            //animOffX = lerp(2, 0, _locallerp) * facingH;
            //animOffY = lerp(-16, 0, _locallerp);
            //animOffAngle = lerp(-4, 0, _locallerp) * facingH;
            animOffX = lerp(-8, 0, _locallerp) * facingH;
            animOffY = lerp(-2, 0, _locallerp);
            animOffAngle = lerp(-10, 0, _locallerp) * facingH;
        }
        else
        {
            animation_set(ePLRANIM.IDLE);
        }
        break;
    
    default:
    case ePLRANIM.IDLE:
        /// First frame routine
        if (!animInit)
        {
            animInit = true;
            animTime = 0;
            animation_set_vars(0, 0, 0, 1, 1);
            
            image_index = 1;
        }
        
        /// Get down
        animOffZ *= 0.8;
        
        /// Update animation conditions
        if (_velmagnitude &gt;= 1)
        {
            animation_set(ePLRANIM.MOVE);
        }
        
        if (facingV) sprite_index = sprPlayer;
        else sprite_index = sprPlayerBack;
        image_xscale = facingH;
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw player quip if player is currently spazzing out
if (quipCtr)
{
    var _delta = min((quipCtrMax-quipCtr) / 40, 1.0);
    var _showstr = string_copy(quipCurrent, 1, _delta * string_length(quipCurrent));
    
    var _bottomdelta = sprite_height;
    
    draw_set_font(fntComicSans);
    draw_text_wave_align(x, y - _bottomdelta - 3, quipCurrent, 1, 1, 0, 1.0, time, 16.0, 12.0 * (1 - _delta * 0.9), 5.0, 1, 2);
    draw_text_wave_hsv(x, y - _bottomdelta - 4, quipCurrent, 1, 1, 0, 200, 255, 1.0, time, 16.0, 12.0 * (1 - _delta * 0.9), 5.0, 1, 2);
    draw_set_font(fntDefault);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw shadow
draw_sprite_ext(sprShadow, 0, x, y, image_xscale, image_yscale, 0, c_white, 1.0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw player
// Draw player
draw_sprite_ext(sprite_index, image_index, x + animOffX, y + animOffY + animOffZ, image_xscale * animXScale, image_yscale * animYScale, image_angle + animOffAngle, image_blend, image_alpha);

// debug : mask
//draw_sprite_ext(mask_index, 0, x, y, image_xscale, image_yscale * animYScale, image_angle + animOffAngle, image_blend, image_alpha);

/*
if (quipCtr) // Weird stuff
{
    time++;
    draw_sprite_ext(sprite_index, 3, x + random_range(-5, 5), y + random_range(-5, 5), image_xscale, image_yscale, image_angle, c_white, 1.0);
}
else // Moving / Idle
{
    if (abs(vx) &lt; 0.2 &amp;&amp; abs(vy) &lt; 0.2) // Idle
    {
        draw_sprite_ext(sprite_index, 1, x, y, image_xscale, image_yscale, image_angle, c_white, 1.0);
    }
    else // Moving
    {
        time += point_distance(0, 0, vx, vy) * 0.128;
        
        // add some bouncy motion
        var _yoff = dsin(time * 20);
        draw_sprite_ext(sprite_index, round(-_yoff + 1), x, y - abs(_yoff) * 16 * min(abs(vx) / 2, 1), image_xscale, image_yscale, image_angle + _yoff * 8, c_white, 1.0);
    }
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
