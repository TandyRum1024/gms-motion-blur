<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-4242</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Main 3D camera
// show_debug_overlay(true);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set camera
mouselock = true;
aspect = view_wview[0] / view_hview[0];
fov = 90;

z = 64; // z pos

lookH = 0; // horizontal rotation
lookV = -0.045; // vertical rotation / pitch
lookR = 0; // "side roll" rotation (think of Quake's wobbly camera when strafing)
lookHDelta = 0; // amount of lookH changed
lookRDelta = 0; // amount of lookR changed

camX = 0; // x offset for camera shake
camY = 0; // y offset for camera shake
camZ = 0; // forward offset for camera shake
camR = 0; // rotation offset for camera shake

/// storing velocity of camera (for shader)
vfwd = 0; // forward
vrh = 0; // horizontal
vrv = 0; // vetical / pitch
vrr = 0; // rotation

// and actual velocity, used to offset the camera
vx = 0;
vy = 0;
vz = 0;
vr = 0;

draw_set_alpha_test(true);
d3d_set_culling(false);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set shader
time = 0;
application_surface_draw_enable(false);
motionblurEnabled = true;

/// Shader related stuff
texBlueNoise = sprite_get_texture(texBluenoise64, 0);

// motionblur : camera velocity [xvel, yvel, zoomvel]
shMotionblurNoise = shader_get_sampler_index(sh_motionblur_fullscreen, "sNoise");
shMotionblurVel = shader_get_uniform(sh_motionblur_fullscreen, "uVelocity");
shMotionblurStr = shader_get_uniform(sh_motionblur_fullscreen, "uStrength");
shMotionblurTime = shader_get_uniform(sh_motionblur_fullscreen, "uTime");
shMotionblurTexsize = shader_get_uniform(sh_motionblur_fullscreen, "uTexsize");
// shMotionblurTex = shader_get_sampler_index(sh_motionblur_linear, "sTex");
// shMotionblurTexinfo = shader_get_uniform(sh_motionblur_linear, "uTexinfo");

texture_set_stage(shMotionblurNoise, texBlueNoise);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// viewmodel?
viewmodelx = 0;
viewmodely = 0;
viewmodelr = 0;
viewmodelScale = 3;

viewmodelvelr = 0;

viewmodelShakeCtr = 0; // Counter for viewmodel shaking
viewmodelShockCtr = 0; // Counter for viewmodel showing ""shocked"" face
viewmodelFacing = 0; // Viewmodel facing direction. -1 = left, 0 = forward, 1 = right
viewmodelSpr = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (unused) FPS physics (unused)
/*
var _axish = keyboard_check(vk_right) - keyboard_check(vk_left);
var _axisv = keyboard_check(vk_down) - keyboard_check(vk_up);
var _axisroll = keyboard_check_pressed(ord('Q')) - keyboard_check_pressed(ord('E'));
var _movesprint = keyboard_check(vk_shift);
var _movefwd = keyboard_check(ord('W')) - keyboard_check(ord('S'));
var _moveside = keyboard_check(ord('D')) - keyboard_check(ord('A'));

if (keyboard_check_pressed(vk_escape))
{
    mouselock = !mouselock;
}

// rotate
var _rotamt = 0;

if (mouselock)
{
    var _cx = window_get_width() * 0.5, _cy = window_get_height() * 0.5;
    _rotamt = (window_mouse_get_x() - _cx) * sensivity; // _axish * 4;
    window_mouse_set(_cx, _cy);
}

lookHDelta = _rotamt;
lookH += _rotamt;
lookV += _axisv * 0.1;
vrr += -_rotamt * 0.02;

if (_axisroll != 0)
    vrr += _axisroll * 20;

lookR += vrr;

// move
if (_movesprint)
    moveVel = moveRunMax;
else
    moveVel = moveMax;

if (_movefwd != 0) accerlate_quake(moveAcc, lookH + 180 * max(-_movefwd, 0));
if (_moveside != 0) accerlate_quake(moveAcc, lookH + 90 + 180 * max(-_moveside, 0));
forwardVel = dot_product(dcos(lookH), dsin(lookH), vx, vy);
//vx = (dcos(lookH) * _movefwd + dcos(lookH + 90) * _moveside) * 2;
//vy = (dsin(lookH) * _movefwd + dsin(lookH + 90) * _moveside) * 2;

var _moveDelta = point_distance(0, 0, vx, vy);
moveCtr += _moveDelta;
camZ = dsin(moveCtr * 4) * (_moveDelta / moveVel) * 5; // headbob

// update pos
x += vx;
y += vy;
z += vz;

if (_movefwd == 0 &amp;&amp; _moveside == 0)
{
    vx *= 0.85;
    vy *= 0.85;
}
else
{
    vx *= 0.95;
    vy *= 0.95;
}

vrr += -lookR * 0.02;
vrr *= 0.9;

// Update viewmodel
var _viewmodelBob = dsin(moveCtr * 2) * (_moveDelta / moveVel);
viewmodelx = _viewmodelBob * 42; // viewmodel bob
viewmodely = abs(dcos(moveCtr * 2) * (_moveDelta / moveVel)) * -16;

viewmodelvelr += _viewmodelBob * 0.05 + _rotamt * 0.035;
viewmodelr += viewmodelvelr;
viewmodelvelr += -viewmodelr * 0.02;
viewmodelvelr *= 0.9;
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update camera motion
vr -= clamp(camR * 0.01, -6.0, 6.0);
vx -= clamp(camX * 0.3, -6.0, 6.0);
vy -= clamp(camY * 0.3, -6.0, 6.0);
vz -= clamp(camZ * 0.3, -6.0, 6.0);

camR += vr;
camX += vx;
camY += vy;
camZ += vz;

vr *= 0.9;
vx *= 0.92;
vy *= 0.92;
vz *= 0.92;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Toggle stuff
if (keyboard_check_pressed(ord("1")))
{
    motionblurEnabled = !motionblurEnabled;
}

if (instance_exists(oThanosCar) &amp;&amp; keyboard_check_pressed(ord("2")))
{
    oThanosCar.shakeEnabled = !oThanosCar.shakeEnabled;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update viewmodel
// calculate viewmodel sprite index
if (viewmodelShockCtr &gt; 0)
{
    viewmodelShockCtr--;
    viewmodelSpr = 3;
}
else
{
    viewmodelSpr = 1 + viewmodelFacing;
}

// update viewmodel shake counter
if (viewmodelShakeCtr &gt; 0)
    viewmodelShakeCtr--;
else
    viewmodelShakeCtr = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (MOTION BLUR) Draw post processed appsurf

if (motionblurEnabled)
{
    // Draw screen pass with motion blur (with interpolation on)
    texture_set_interpolation(true);
    shader_set(sh_motionblur_fullscreen);
    
    // surface size / texture size
    shader_set_uniform_f(shMotionblurTexsize, surface_get_width(application_surface), surface_get_height(application_surface));
    
    // blur info
    time++;
    shader_set_uniform_f(shMotionblurTime, time * 0.1);
    
    // remap the velocity so that subtle movements doesn't make a lot of blur
    var _vf = min(max(0, abs(vfwd) - 4.0) / 16.0, 1.0);
    
    shader_set_uniform_f(shMotionblurVel, vrh + vx, vrv + vz, _vf, -vrr - vr); // set camera velocities
    shader_set_uniform_f(shMotionblurStr, 4.0, 0.5, 0.0); // motion blur OFF
    //shader_set_uniform_f(shMotionblurStr, 4.0, 0.5, 1.0); // set motion blur strength
    
    // draw screen pass
    draw_surface(application_surface, 0, 0);
    shader_reset();
    texture_set_interpolation(false);
}
else
{
    draw_surface(application_surface, 0, 0);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// viewmodel / HUD
var _hudx = window_get_width() &gt;&gt; 1, _hudy = window_get_height() - 21;
var _colour = make_colour_hsv(time * 2.0, 255, 255); // rainbow colour

/// Viewmodel
var _vsx = random_range(-viewmodelShakeCtr, viewmodelShakeCtr), _vsy = random_range(-viewmodelShakeCtr, viewmodelShakeCtr), _vsr = random_range(-viewmodelShakeCtr, viewmodelShakeCtr) * 0.8;
var _vmx = _hudx + random_range(-viewmodelShakeCtr, viewmodelShakeCtr), _vmy = window_get_height() - 21 + viewmodely;
draw_sprite_ext(sprViewThanno, viewmodelSpr, _vmx + _vsx, _vmy + _vsy, viewmodelScale, viewmodelScale, _vsr, c_white, 1);

/// HUD
// calculate metre per second
var _metreperframe = vfwd / 8;
var _mph = _metreperframe * 26.8224;

var _t = _mph * 0.5 + 1.0; // animation time
var _hudstr = string(_mph) + " MPH";
var _hudrot = dsin(_t * 2.0) * 5 + dcos(_t * 4.5 + 42.0) * 2 + dsin(_t * 10.0 + 84.0) * 1.2;
var _hudscale = viewmodelScale * 0.5;

draw_set_halign(1); draw_set_valign(1);
draw_set_font(fntMenuTiny);
draw_text_transformed_colour(_hudx + viewmodelx + 2, _hudy + viewmodely + 2, _hudstr, _hudscale, _hudscale, viewmodelr + _hudrot, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(_hudx + viewmodelx, _hudy + viewmodely, _hudstr, _hudscale, _hudscale, viewmodelr + _hudrot, _colour, _colour, _colour, _colour, 1.0);
draw_set_font(fntDefault);
draw_set_halign(0); draw_set_valign(0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw FPS counter &amp; info
var _wid = window_get_width() - 10;
var _infoy = 10, _infostr = "FPS : " + string(fps_real), _infocol = c_yellow;

// draw fps
draw_set_font(fntDefault);
draw_text_colour(10 + 2, _infoy + 2, _infostr, c_black, c_black, c_black, c_black, 1.0);
draw_text_colour(10, _infoy, _infostr, _infocol, _infocol, _infocol, _infocol, 1.0);

// draw info
_infoy += 30;
if (motionblurEnabled)
{
    _infostr = "Press [1] to toggle Motion blur! (Blur : ON)";
    _infocol = c_lime;
}
else
{
    _infostr = "Press [1] to toggle Motion blur! (Blur : OFF)";
    _infocol = c_yellow;
}
draw_text_transformed_colour(10 + 2, _infoy + 2, _infostr, 0.8, 0.8, 0, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(10, _infoy, _infostr, 0.8, 0.8, 0, _infocol, _infocol, _infocol, _infocol, 1.0);

_infoy += 30;
if (instance_exists(oThanosCar) &amp;&amp; oThanosCar.shakeEnabled)
{
    _infostr = "Press [2] to toggle Camera shake (Shake : ON)";
    _infocol = c_lime;
}
else
{
    _infostr = "Press [2] to toggle Camera shake (Shake : OFF)";
    _infocol = c_yellow;
}
draw_text_transformed_colour(10 + 2, _infoy + 2, _infostr, 0.8, 0.8, 0, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(10, _infoy, _infostr, 0.8, 0.8, 0, _infocol, _infocol, _infocol, _infocol, 1.0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw end
d3d_end();
d3d_set_projection_ortho(0,0,window_get_width(),window_get_height(),0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set projection
var _lookcos = dcos(lookH);
var _looksin = dsin(lookH);
var _lookcos2 = dcos(lookH + 90);
var _looksin2 = dsin(lookH + 90);

var _targetx = x + _lookcos, _targety = y + _looksin, _targetz = z + lookV;
var _rollx = 0, _rolly = 1 * dsin(lookR + camR), _rollz = 1 * dcos(lookR + camR);
var _xup = _rollx * _lookcos - _rolly * _looksin;
var _yup = _rollx * _looksin + _rolly * _lookcos;
var _zup = _rollz;

var _xoff = camX * _lookcos2 - camY * _looksin2;
var _yoff = camX * _looksin2 + camY * _lookcos2;

d3d_start();
d3d_set_projection_ext(x + _xoff, y + _yoff, z + camZ, _targetx + _xoff, _targety + _yoff, _targetz + camZ, _xup, _yup, _zup, fov, aspect, 0.01, 6666);
//d3d_set_projection_ext(x, y, z, _targetx, _targety, _targetz, _rollx, _rolly, _rollz, fov, aspect, 0.01, 6666);
/*
var _pmat;
var _lookmat = matrix_build(0,0,0, lookV, lookH, lookR, 1,1,1);
var _lookmat = matrix_build(0,0,0, lookV, lookH, lookR, 1,1,1);

matrix_set(matrix_projection, _pmat);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw sky
var _dist = 5000;
d3d_draw_cylinder(x - _dist, y - _dist, z + _dist, x + _dist, y + _dist, z - _dist, sprite_get_texture(tex3DBG, 0), 1, 1, true, 64);
d3d_draw_floor(-6400, -6400, -4, 6400, 6400, -4, sprite_get_texture(texFloor, 1), 200, 200);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
