<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprThannoKdrive</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-4241</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Physics related variables
mask_index = sprMask32;

z = 4;
vx = 0;
vy = 0;

velocity = 0;

accel = 0.090; //0.06; // vehicle acceleration
accelMax = 8.0;
tractionFactor = 0.05; // vehicle traction force factor
traction = 0.15; // vehicle max traction

totalVel = 0; // vehicle's current velocity magnitude
forwardVel = 0; // vehicle's current forward velocity
sideVel = 0; // vehicle's current forward velocity

rotation = 0; // current rotation
rotationVel = 0; // angular velocity
rotationAccel = 1.8;//0.15; // rotation speed

// cached sine and cosined vehicle rotation
rotationSin = dsin(rotation);
rotationCos = dcos(rotation);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera shake &amp; animation &amp; misc related variables
camera = noone;
cameraRoataionFactor = 0.1; // camera rotation lerp factor

shaketime = 0;
shakeEnabled = true;
shakeIntensityFactor = 0.5; // intensity factor for each octaves
shakeBaseIntensity = 0.8; // camera shake base intensity
shakeBaseSpeed = 0.02; // camera shake base speed

// animation
time = 0; // time variable for animation
facing = 1; // Mr. T's facing direction

// texture
texKdrive = sprite_get_texture(sprThannoKdrive, 0);
texKdriveShadow = sprite_get_texture(sprThannoKdrive, 1);
texThanno = sprite_get_texture(sprThanno, 3);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Fetch camera object
with (oKNT_3DDEMO)
{
    other.camera = id;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera related stuff
if (camera != noone)
{
    // aim camera towards vehicle
    var _deltarot = -angle_difference(camera.lookH, rotation) * cameraRoataionFactor;
    camera.lookH += _deltarot;
    
    // hijack camera's position
    var _deltax = camera.x;
    var _deltay = camera.y;
    var _offx = -dcos(rotation) * 80.0;
    var _offy = -dsin(rotation) * 80.0;
    camera.x = lerp(camera.x, x + _offx, 0.08);
    camera.y = lerp(camera.y, y + _offy, 0.08);
    
    // Calculate camera's velocity
    var _sin = dsin(camera.lookH);
    var _cos = dcos(camera.lookH);
    var _sin2 = dsin(camera.lookH + 90);
    var _cos2 = dcos(camera.lookH + 90);
    _deltax = camera.x - _deltax;
    _deltay = camera.y - _deltay;
    
    var _sidevel = dot_product(_cos2, _sin2, _deltax, _deltay) * 0.1;
    var _fwdvel = dot_product(_cos, _sin, _deltax, _deltay);
    
    // apply camera velocity for motion blur
    camera.vfwd = _fwdvel;
    camera.vrh = _deltarot + _sidevel;
    camera.vr += (_deltarot + _sidevel) * 0.062;
    
    // camera shake
    if (shakeEnabled)
    {
        var _vehicleSpeed = min(point_distance(0, 0, vx, vy) * 0.5, 1.0);
        var _shakeSpeed = shakeBaseSpeed * _vehicleSpeed * 10.5;
        
        shaketime += _shakeSpeed;
        var _shakeIntensity = shakeBaseIntensity * _vehicleSpeed;
        
        // make varying octaves of sine to simulate natural shaking
        for (var i=0; i&lt;6; i++)
        {
            // show_debug_message("OCTAVE " + string(i) + " : " + string(sin(shaketime + i * 1.28 + 2.14 * i) * _shakeIntensity));
            // var _speedFactor = 1.0 + i * 0.15;
            var _t = shaketime * (1.0 + i * 0.15) - i * 3.88;
            
            camera.vx += sin(_t + 1.14) * _shakeIntensity;
            camera.vy += cos(_t + 2.14) * _shakeIntensity;
            camera.vz += cos(_t + 3.14) * _shakeIntensity;
            camera.vr += cos(_t * 2.0 + 4.42) * (_shakeIntensity * 0.08);
            _shakeIntensity *= shakeIntensityFactor;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vehicle / hoveboard physics
// inputs
var _inputH = keyboard_check(ord("D")) - keyboard_check(ord("A"));
var _inputV = keyboard_check(ord("W")) - keyboard_check(ord("S"));
var _fart = keyboard_check_pressed(vk_space);

// update rotation
//rotationVel += rotationAccel * _inputH;// * clamp(forwardVel * 0.08 - 0.2, 0.2, 1.0);
rotation += rotationAccel * _inputH; //rotationVel;
rotationSin = dsin(rotation);
rotationCos = dcos(rotation);
    
// Update velocity variables
totalVel = point_distance(0, 0, vx, vy);
forwardVel = dot_product(rotationCos, rotationSin, vx, vy)
sideVel = dot_product(-rotationSin, rotationCos, vx, vy); // we switch sine and cosine as we need vector perpendicular to the rotation (AKA "side" vector)

// accelerate
if (_inputV != 0)
{
    var _accelAdd = accel * _inputV;
    _accelAdd = min(accelMax - forwardVel, _accelAdd);
    
    vx += rotationCos * _accelAdd;
    vy += rotationSin * _accelAdd;
    
    particle3d_flash_emit(4, 12, x - rotationCos * 16, y - rotationSin * 16, z, vx * 0.5, vy * 0.5, 0.1);
}

// apply traction / side friction
// https://www.youtube.com/watch?v=LG1CtlFRmpU
if (sideVel != 0.0 &amp;&amp; totalVel != 0.0)
{
    var _tractionForce = clamp(sideVel * tractionFactor, -traction, traction);
    // show_debug_message(_tractionForce);
    vx -= -rotationSin * _tractionForce;
    vy -= rotationCos * _tractionForce;
    
    //vx += rotationCos * _tractionForce;
    //vy += rotationSin * _tractionForce;    
}

// dampen
if (_inputV == 0.0)
{
    vx *= 0.99;
    vy *= 0.99;
}

rotationVel *= 0.9;

// collision check &amp; update position
var _hitVel = 0;
var _sv = sign(vx);
var _off = 0;
if (place_meeting(x + vx, y, oBlock3D))
{
    while (!place_meeting(x + _off + _sv, y, oBlock3D) &amp;&amp; abs(_off) &lt; 33)
        _off += _sv;
    
    // bounce off
    if (_off &lt;= 32)
    {
        _hitVel += abs(vx); // accumulate hit velocity
        
        // solve collision &amp; bounce off
        x += _off
        vx *= -0.5;
    }
}
x += vx;

_sv = sign(vy);
_off = 0;
if (place_meeting(x, y + vy, oBlock3D))
{
    while (!place_meeting(x, y + _off + _sv, oBlock3D) &amp;&amp; abs(_off) &lt; 33)
        _off += _sv;
    
    // bounce off
    if (_off &lt;= 32)
    {
        _hitVel += abs(vy); // accumulate hit velocity
        
        // solve collision &amp; bounce off
        y += _off
        vy *= -0.5;
    }
}
y += vy;

if (_hitVel &gt;= 0.2)
{
    camera.viewmodelShakeCtr = _hitVel; // Shake the viewmodel

    // emit spark
    particle3d_spark_emit(4 + random_range(-2, 2), irandom_range(8, 12), x + random_range(-2, 2), y + random_range(-2, 2), z + random_range(-2, 2), random_range(-1.0, 1.0), random_range(-1.0, 1.0), random_range(0.1, 0.8));
        
    if (_hitVel &gt;= 4)
    {
        camera.viewmodelShockCtr = 30; // show shocked face
        
        // emit smoke if we hit something real hard
        repeat (floor(_hitVel) + irandom_range(2, 3))
            particle3d_smoke_emit(8 + random_range(-4, 2), irandom_range(8, 24), x + random_range(-16, 16), y + random_range(-16, 16), z + random_range(-16, 16), random_range(-0.5, 0.5), random_range(-0.5, 0.5), random_range(0.1, 0.8));
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (old &amp; unused) physics
/*
// update time for various animation related stuff
time += 1.0;

// get inputs
var _inputH = keyboard_check(ord("D")) - keyboard_check(ord("A"));
var _inputV = keyboard_check(ord("W")) - keyboard_check(ord("S"));
var _rotcos = dcos(rotation);
var _rotsin = dsin(rotation);

var _dirDelta = sign(camera.lookH - rotation);
if (_dirDelta != 0)
    facing = _dirDelta;

// move forward / backward
if (_inputV != 0)
{
    velocity += _inputV * accel;
}
// update rotation
if (_inputH != 0)
{
    rotation += _inputH * 2.0;
    camera.viewmodelSpr = 1 + (_inputH * -0.5 + 0.5);
}
else
{
    camera.viewmodelSpr = 0;
}
*/

/*
/// FPS movement
if (_inputV != 0)
{
    accerlate_quake(accel, 16.0, rotation + max(0, 180 * -_inputV));
}
if (_inputH2 != 0)
{
    accerlate_quake(accel, 16.0, rotation + 90 + max(0, 180 * -_inputH2));
}
//vx += _rotcos * _inputV;
//vy += _rotsin * _inputV;

// friction
vx *= 0.99;
vy *= 0.99;
*/

/*
vx = lerp(vx, lengthdir_x(velocity, -rotation), 0.08);
vy = lerp(vy, lengthdir_y(velocity, -rotation), 0.08);
velocity *= 0.995;

// integrate
x += vx;
y += vy;
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update T**NOS' facing
var _face = dot_product(dcos(camera.lookH), dsin(camera.lookH), -rotationSin, rotationCos);

if (abs(_face) &lt;= 0.08)
{
    facing = 0;
}
else
{
    facing = sign(_face);
}

// update facing-dependant textures/sprites
texThanno = sprite_get_texture(sprThanno, 1 + facing);

// update viewmodel
camera.viewmodelFacing = facing;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug draw
/*
var _cx = window_get_width() * 0.5, _cy = window_get_height() * 0.5;
var _len = 64;

// Car orientation
draw_line_width_colour(_cx, _cy, _cx + rotationCos * _len, _cy + rotationSin * _len, 4, c_lime, c_lime);

// Car forward velocity
var _ox = _cx - rotationSin * 8, _oy = _cy + rotationCos * 8;
draw_line_width_colour(_ox, _oy, _ox + rotationCos * forwardVel, _oy + rotationSin * forwardVel, 2, c_blue, c_blue);

// Car side velocity
var _svel = abs(sideVel);
draw_line_width_colour(_cx, _cy, _cx - rotationSin * _svel, _cy + rotationCos * _svel, 2, c_red, c_red);
*/
// show_debug_message(sideVel);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw car... thing?
var _sz = 16;
var _szThanos = 16;

d3d_transform_stack_push();
d3d_transform_add_rotation_z(-rotation - 90);
d3d_transform_add_translation(x, y, 0);
// Board
d3d_draw_floor(-_sz, -_sz, 0, _sz, _sz, 0, texKdriveShadow, 1, 1);
d3d_draw_floor(-_sz, -_sz, z, _sz, _sz, z, texKdrive, 1, 1);

// TH*NOS
d3d_draw_wall(-_szThanos, 0, z + _szThanos * 2, _szThanos, 0, z, texThanno, 1, 1);
//d3d_draw_wall(-_sz, 0, _sz * 2, _sz, 0, 0, tex2, 1, 1);
d3d_transform_stack_pop();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
