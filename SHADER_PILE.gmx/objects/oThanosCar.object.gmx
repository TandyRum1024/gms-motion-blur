<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprThannoKdrive</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-4241</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Physics related variables
z = 4;
vx = 0;
vy = 0;

accel = 0.08; // vehicle acceleration
traction = 0.5; // vehicle traction

totalVel = 0; // vehicle's current velocity magnitude
forwardVel = 0; // vehicle's current forward velocity
sideVel = 0; // vehicle's current forward velocity

rotation = 0; // current rotation
rotationAccel = 5; // rotation speed

// cached sine and cosined vehicle rotation
rotationSin = dsin(rotation);
rotationCos = dcos(rotation);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera shake &amp; animation &amp; misc related variables
camera = noone;
cameraRoataionFactor = 0.1; // camera rotation lerp factor

shaketime = 0;
shakeEnabled = true;
shakeIntensityFactor = 0.5; // intensity factor for each octaves
shakeBaseIntensity = 0.8; // camera shake base intensity
shakeBaseSpeed = 0.02; // camera shake base speed

// animation
time = 0; // time variable for animation
facing = 1; // Mr. T's facing direction

// texture
texKdrive = sprite_get_texture(sprThannoKdrive, 0);
texKdriveShadow = sprite_get_texture(sprThannoKdrive, 1);
texThanno = sprite_get_texture(sprThanno, 3);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Fetch camera object
with (oKNT_3DDEMO)
{
    other.camera = id;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera related stuff
if (camera != noone)
{
    // aim camera towards vehicle
    var _deltarot = -angle_difference(camera.lookH, rotation) * cameraRoataionFactor;
    camera.lookH += _deltarot;
    
    // hijack camera's position
    var _deltax = camera.x;
    var _deltay = camera.y;
    var _offx = -dcos(rotation) * 80.0;
    var _offy = -dsin(rotation) * 80.0;
    camera.x = lerp(camera.x, x + _offx, 0.08);
    camera.y = lerp(camera.y, y + _offy, 0.08);
    
    // Calculate camera's velocity
    var _sin = dsin(camera.lookH);
    var _cos = dcos(camera.lookH);
    var _sin2 = dsin(camera.lookH + 90);
    var _cos2 = dcos(camera.lookH + 90);
    _deltax = camera.x - _deltax;
    _deltay = camera.y - _deltay;
    
    var _sidevel = dot_product(_cos2, _sin2, _deltax, _deltay);
    var _fwdvel = dot_product(_cos, _sin, _deltax, _deltay);
    
    // apply camera velocity for motion blur
    camera.vfwd = _fwdvel;
    camera.vrh = _deltarot + _sidevel;
    camera.vr += (_deltarot + _sidevel) * 0.062;
    
    // camera shake
    if (shakeEnabled)
    {
        var _vehicleSpeed = min(point_distance(0, 0, vx, vy) * 0.5, 1.0);
        var _shakeSpeed = shakeBaseSpeed * _vehicleSpeed * 10.5;
        
        shaketime += _shakeSpeed;
        var _shakeIntensity = shakeBaseIntensity * _vehicleSpeed;
        
        // make varying octaves of sine to simulate natural shaking
        for (var i=0; i&lt;6; i++)
        {
            // show_debug_message("OCTAVE " + string(i) + " : " + string(sin(shaketime + i * 1.28 + 2.14 * i) * _shakeIntensity));
            // var _speedFactor = 1.0 + i * 0.15;
            var _t = shaketime * (1.0 + i * 0.15) - i * 3.88;
            
            camera.vx += sin(_t + 1.14) * _shakeIntensity;
            camera.vy += cos(_t + 2.14) * _shakeIntensity;
            camera.vz += cos(_t + 3.14) * _shakeIntensity;
            camera.vr += cos(_t * 2.0 + 4.42) * (_shakeIntensity * 0.08);
            _shakeIntensity *= shakeIntensityFactor;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vehicle / hoveboard physics
// inputs
var _inputH = keyboard_check(ord("D")) - keyboard_check(ord("A"));
var _inputV = keyboard_check(ord("W")) - keyboard_check(ord("S"));

// update rotation
rotation += rotationAccel * _inputH;
rotationSin = dsin(rotation);
rotationCos = dcos(rotation);

// accelerate
vx += _cos * accel * _inputV;
vy += _sin * accel * _inputV;

// Update velocity variables
totalVel = point_distance(0, 0, vx, vy);
forwardVel = dot_product(rotationCos, rotationSin, vx, vy)
sideVel = dot_product(-rotationSin, rotationCos, vx, vy); // we switch sine and cosine as we need vector perpendicular to the rotation (AKA "side" vector)

// apply traction
// https://www.youtube.com/watch?v=LG1CtlFRmpU
/*
if (sideVel != 0.0 &amp;&amp; totalVel != 0.0)
{
    var _tractionForce = sideVel * traction;
    vx -= _sin * _tractionForce;
    vy -= _cos * _tractionForce;
}
*/
// integrate
x += vx;
y += vy;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (old &amp; unused) physics
/*
// update time for various animation related stuff
time += 1.0;

// get inputs
var _inputH = keyboard_check(ord("D")) - keyboard_check(ord("A"));
var _inputH2 = keyboard_check(vk_right) - keyboard_check(vk_left);
var _inputV = keyboard_check(ord("W")) - keyboard_check(ord("S"));
var _rotcos = dcos(rotation);
var _rotsin = dsin(rotation);

var _dirDelta = sign(camera.lookH - rotation);
if (_dirDelta != 0)
    facing = _dirDelta;

// move forward / backward
if (_inputV != 0)
{
    velocity += _inputV * accel;
}
// update rotation
if (_inputH != 0)
{
    rotation += _inputH * 2.0;
    camera.viewmodelSpr = 1 + (_inputH * -0.5 + 0.5);
}
else
{
    camera.viewmodelSpr = 0;
}
*/

/*
/// FPS movement
if (_inputV != 0)
{
    accerlate_quake(accel, 16.0, rotation + max(0, 180 * -_inputV));
}
if (_inputH2 != 0)
{
    accerlate_quake(accel, 16.0, rotation + 90 + max(0, 180 * -_inputH2));
}
//vx += _rotcos * _inputV;
//vy += _rotsin * _inputV;

// friction
vx *= 0.99;
vy *= 0.99;
*/

/*
vx = lerp(vx, lengthdir_x(velocity, -rotation), 0.08);
vy = lerp(vy, lengthdir_y(velocity, -rotation), 0.08);
velocity *= 0.99;

// integrate
x += vx;
y += vy;
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug draw
var _cx = window_get_width() * 0.5, _cy = window_get_height() * 0.5;
var _len = 64;

// Car orientation
draw_line_width_colour(_cx, _cy, _cx + rotationCos * _len, _cy + rotationSin * _len, 4, c_lime, c_lime);

// Car forward velocity
var _ox = _cx - rotationSin * 8, _oy = _cy + rotationCos * 8;
draw_line_width_colour(_ox, _oy, _ox + rotationCos * forwardVel, _oy + rotationSin * forwardVel, 2, c_blue, c_blue);

// Car side velocity
var _svel = abs(sideVel);
draw_line_width_colour(_cx, _cy, _cx - rotationSin * _svel, _cy + rotationCos * _svel, 2, c_red, c_red);
show_debug_message(sideVel);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw car... thing?
var _sz = 16;
var _szThanos = 16;

d3d_transform_stack_push();
d3d_transform_add_rotation_z(-rotation - 90);
d3d_transform_add_translation(x, y, 0);
// Board
d3d_draw_floor(-_sz, -_sz, 0, _sz, _sz, 0, texKdriveShadow, 1, 1);
d3d_draw_floor(-_sz, -_sz, z, _sz, _sz, z, texKdrive, 1, 1);

// TH*NOS
d3d_draw_wall(-_szThanos * facing, 0, z + _szThanos * 2, _szThanos * facing, 0, z, texThanno, 1, 1);
//d3d_draw_wall(-_sz, 0, _sz * 2, _sz, 0, 0, tex2, 1, 1);
d3d_transform_stack_pop();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
