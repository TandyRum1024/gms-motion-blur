<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertex buffer controller object
time = 0;

model = d3d_model_create();
vbuffStatic = vertex_create_buffer();
vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_textcoord();
vertex_format_add_colour();
vfmt = vertex_format_end();

vtxCount = 0;
vbuffStaticUpdated = false;

// model for flag
modelFlag = d3d_model_create();
modelFlagUpdated = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// setup texture atlas (warning : magic numbers galore)
define_tex_idx();

var _len = array_height_2d(global.textureList);
var _sprNum = global.textureList[@ _len-1, 1] + global.textureList[@ _len-1, 2];
var _sprWid = 32, _sprHei = 32, _texIdx;
var surf = surface_create(_sprNum * _sprWid, _sprHei);

surface_set_target(surf);
for (var i=0; i&lt;array_height_2d(global.textureList); i++)
{
    // show_debug_message("SPR : " + string(sprite_get_name(global.textureList[@ i, 0])) + " OFF : " + string(global.textureList[@ i, 1]) + " LEN : " + string(global.textureList[@ i, 2]));
    for (var j=0; j&lt;global.textureList[@ i, 2]; j++)
    {
        _texIdx = global.textureList[@ i, 1] + j;
        draw_sprite(global.textureList[@ i, 0], j, _texIdx * _sprWid, 0);
    }
}
surface_reset_target();

// immortalize the texture atlas by making it into sprite
global.textureSpr = sprite_create_from_surface(surf, 0, 0, surface_get_width(surf), surface_get_height(surf), false, false, 0, 0);
global.textureAtlas = sprite_get_texture(global.textureSpr, 0);
global.textureAtlasWid = texture_get_texel_width(global.textureAtlas); // store inverse so that we can just multiply it
global.textureAtlasHei = texture_get_texel_height(global.textureAtlas);
global.textureAtlasTexWid = _sprWid;
global.textureAtlasTexHei = _sprHei;
global.textureAtlasUnitWid = _sprWid * global.textureAtlasWid;

surface_free(surf);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup shaders
shFadeResolution = shader_get_uniform(shd_3d_fade, "uScreenSize");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>d3d_model_destroy(modelFlag);
d3d_model_destroy(model);
vertex_format_delete(vfmt);
vertex_delete_buffer(vbuffStatic);

sprite_delete(global.textureSpr);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update static world mesh
if (!vbuffStaticUpdated)
{
    vbuffStaticUpdated = true;
    
    var _vb = vbuffStatic;
    vertex_begin(_vb, vfmt);
    with (oVTXBLOCK)
    {
        vb_add_wall(_vb, x, y, z, sizeX, sizeY, 32, texIdx, c_white, 1.0);
        vb_add_wall(_vb, x, y + sizeY, z, sizeX, -sizeY, 32, texIdx, c_white, 1.0);
        // vb_add_wall(_vb, x, y + sizeY, 32, sizeX, -sizeY, -32, texIdx, c_white, 1.0);
        // vb_add_floor(_vb, x - 16, y - 16, z, 32, 32, 0, 0, c_white, 1.0);
    }
    vertex_end(_vb);
    vertex_freeze(_vb);
}

if (!modelFlagUpdated)
{
    modelFlagUpdated = true;
    var _mdl = modelFlag;
    d3d_model_clear(_mdl);
    d3d_model_primitive_begin(_mdl, pr_trianglelist);
    with (oFlag)
    {
        d3d_model_wall(_mdl, x, y, z, x + sizeX, y + sizeY, 0, 1, 1);
        //mdl_add_wall(modelFlag, x - sizeX, y - sizeY, 0, sizeX * 2.0, sizeY * 2.0, -z, texIdx, c_white, 1.0);
    }
    d3d_model_primitive_end(_mdl);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Prepare vertex buffer
//time++;
var _alpha = 1.0; // billboards alpha //(dsin(time * 5) * 0.5 + 0.5);

var _mdl = model;
var _camx = 0, _camy = 0, _camanglecos = 0, _camanglesin = 0;
var _camfov = 45;

// Get camera position and looking rotation
with (oKNT_3DDEMO)
{
    _camx = x;
    _camy = y;
    _camanglecos = dcos(lookH);
    _camanglesin = dsin(lookH);
    _camfov = fov * 0.5;
}

d3d_model_clear(_mdl);
d3d_model_primitive_begin(_mdl, pr_trianglelist);

// Draw billboarded sprites
with (oVTXSPR)
{
    /*
    //unused but interesting alternative culling stuff
    var _tdir = point_direction(_camx, _camy, x, y);
    var _dirx = dcos(_tdir);
    var _diry = dsin(_tdir);
    */

    // cull
    var _tdist = 1 / point_distance(_camx, _camy, x, y);
    var _dirx = (x - _camx) * _tdist;
    var _diry = (y - _camy) * _tdist;
    var _anglediff = (1 - dot_product(_camanglecos, _camanglesin, _dirx, _diry)) * 90;
    
    if (_anglediff &lt; _camfov + radius)
    {
        var _offx = _diry * -size, _offy = _dirx * size;
        if (drawShadow) mdl_add_floor(_mdl, x - size, y - size, 0, size * 2, size * 2, 0, 0, c_white, 1.0);
        mdl_add_wall(_mdl, x - _offx, y - _offy, z + size, _offx * 2, _offy * 2, size * 2, texIdx, c_white, _alpha);
    }
}

// Draw car
with (oPlayer)
{
    mdl_add_floor_rot(_mdl, x, y, 0, size, rotation, texIdx + 4, 1, 1);
    mdl_add_floor_rot(_mdl, x, y, z, size, rotation, texIdx + 3, c_white, 1);
    
    var _offx = rotationSin * -size, _offy = rotationCos * size;
    mdl_add_wall(_mdl, x - _offx, y - _offy, z + size * 2, _offx * 2, _offy * 2, size * 2, texIdx + 1 + facing, c_white, _alpha);
}
d3d_model_primitive_end(_mdl);

// submit sprites &amp; world mesh
vertex_submit(vbuffStatic, pr_trianglelist, global.textureAtlas);

// set fade shader and uniform
shader_set(shd_3d_fade);
shader_set_uniform_f(shFadeResolution, window_get_width(), window_get_height());

d3d_model_draw(modelFlag, 0, 0, 0, sprite_get_texture(texFlag, 0)); // Draw flag (exceptional case of drawing stuff)
d3d_model_draw(model, 0, 0, 0, global.textureAtlas);
shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
