<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertex buffer controller object
model = d3d_model_create();
vbuffStatic = vertex_create_buffer();
vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_textcoord();
vertex_format_add_colour();
vfmt = vertex_format_end();

vtxCount = 0;
vbuffStaticUpdated = false;

// model for flag
modelFlag = d3d_model_create();
modelFlagUpdated = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// setup texture atlas
var _sprNum1 = sprite_get_number(tex3D), _sprNum2 = sprite_get_number(tex3DParticle);
var _sprWid = sprite_get_width(tex3D), _sprHei = sprite_get_height(tex3D);
var surf = surface_create((_sprNum1 + _sprNum2) * _sprWid, _sprHei);
surface_set_target(surf);
for (var i=0; i&lt;_sprNum1; i++)
    draw_sprite(tex3D, i, i * _sprWid, 0);
for (var i=0; i&lt;_sprNum2; i++)
    draw_sprite(tex3DParticle, i, _sprNum1 * _sprWid + i * _sprWid, 0);
surface_reset_target();

// immortalize the texture atlas by making it into sprite
global.textureSpr = sprite_create_from_surface(surf, 0, 0, surface_get_width(surf), surface_get_height(surf), false, false, 0, 0);
global.textureAtlas = sprite_get_texture(global.textureSpr, 0);
global.textureAtlasWid = texture_get_texel_width(global.textureAtlas); // store inverse so that we can just multiply it
global.textureAtlasHei = texture_get_texel_height(global.textureAtlas);
global.textureAtlasTexWid = _sprWid;
global.textureAtlasTexHei = _sprHei;
global.textureAtlasUnitWid = _sprWid * global.textureAtlasWid;

surface_free(surf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update static world mesh
if (!vbuffStaticUpdated)
{
    vbuffStaticUpdated = true;
    
    var _vb = vbuffStatic;
    vertex_begin(_vb, vfmt);
    with (oVTXBLOCK)
    {
        vb_add_wall(_vb, x, y, z, sizeX, sizeY, 32, texIdx, c_white, 1.0);
        vb_add_wall(_vb, x, y + sizeY, z, sizeX, -sizeY, 32, texIdx, c_white, 1.0);
        // vb_add_wall(_vb, x, y + sizeY, 32, sizeX, -sizeY, -32, texIdx, c_white, 1.0);
        // vb_add_floor(_vb, x - 16, y - 16, z, 32, 32, 0, 0, c_white, 1.0);
    }
    vertex_end(_vb);
    vertex_freeze(_vb);
}

if (!modelFlagUpdated)
{
    modelFlagUpdated = true;
    var _mdl = modelFlag;
    d3d_model_clear(_mdl);
    d3d_model_primitive_begin(_mdl, pr_trianglelist);
    with (oFlag)
    {
        d3d_model_wall(_mdl, x - sizeX, y - sizeY, z, x + sizeX, y + sizeY, 0, 1, 1);
        //mdl_add_wall(modelFlag, x - sizeX, y - sizeY, 0, sizeX * 2.0, sizeY * 2.0, -z, texIdx, c_white, 1.0);
    }
    d3d_model_primitive_end(_mdl);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Prepare vertex buffer
var _mdl = model;
var _camx = 0, _camy = 0, _camanglecos = 0, _camanglesin = 0;
var _camfov = 45;

// Get camera position and looking rotation
with (oKNT_3DDEMO)
{
    _camx = x;
    _camy = y;
    _camanglecos = dcos(lookH);
    _camanglesin = dsin(lookH);
    _camfov = fov * 0.5;
}

// Draw billboarded sprites
d3d_model_clear(_mdl);
d3d_model_primitive_begin(_mdl, pr_trianglelist);
with (oVTXSPR)
{
    /*
    //unused but interesting alternative culling stuff
    var _tdir = point_direction(_camx, _camy, x, y);
    var _dirx = dcos(_tdir);
    var _diry = dsin(_tdir);
    */

    // cull
    var _tdist = 1 / point_distance(_camx, _camy, x, y);
    var _dirx = (x - _camx) * _tdist;
    var _diry = (y - _camy) * _tdist;
    var _anglediff = (1 - dot_product(_camanglecos, _camanglesin, _dirx, _diry)) * 90;
    
    if (_anglediff &lt; _camfov + radius)
    {
        var _offx = _diry * -size, _offy = _dirx * size;
        if (drawShadow) mdl_add_floor(_mdl, x - size, y - size, 0.0, size * 2.0, size * 2.0, 0.0, 3, c_white, 1.0);
        mdl_add_wall(_mdl, x - _offx, y - _offy, z + size, _offx * 2.0, _offy * 2.0, size * 2.0, texIdx, c_white, 1.0);
    }
}
d3d_model_primitive_end(_mdl);

// submit sprites &amp; world mesh
vertex_submit(vbuffStatic, pr_trianglelist, global.textureAtlas);
d3d_model_draw(modelFlag, 0, 0, 0, sprite_get_texture(texFlag, 0)); // Draw flag (exceptional case of drawing stuff)
d3d_model_draw(model, 0, 0, 0, global.textureAtlas);
//vertex_submit(vbuff, pr_trianglelist, global.textureAtlas);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
