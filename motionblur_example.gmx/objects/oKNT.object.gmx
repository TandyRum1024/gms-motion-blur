<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// UI &amp; screen stuff
winW = window_get_width();
winH = window_get_height();
iui_init();

uiVelX = "0";
uiVelY = "0";
uiVelZ = "0";
uiVelR = "0";
uiStrength = "1";

uiDither = true;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Surfaces &amp; motion blur shader
surfW = floor(winW * 0.45);
surfH = floor(winH * 0.6);

surfResult = surface_create(surfW, surfH);
surfMotions = surface_create(surfW, surfH);

// shader properties
time = 0; // current frame
ditherEnabled = true;

velX = 0;
velY = 0;
velZoom = 0;
velRot = 0;
velStrength = 1;

noiseTex = sprite_get_texture(texBlueNoise64, 0);
shVecTexSz = shader_get_uniform(sh_motionblur_showmotion, "uTexsize");
shVecVel = shader_get_uniform(sh_motionblur_showmotion, "uVelocity");
shVecStr = shader_get_uniform(sh_motionblur_showmotion, "uStrength");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// UI
var _cx = winW * 0.5, _cy = winH * 0.5;
iui_update_io();
iui_begin();

var _uiheight = 128;
var _uix = 10;

iui_rect(0, 0, winW, _uiheight-2, $2f2b2c);
iui_rect(0, _uiheight-2, winW, 2, 0);

iui_label(_uix, 20, "VELOCITY [X, Y, ZOOM, ROT]", $3e6eef);
uiVelX = iui_textbox_numberonly(_uix, 64, 80, 24, uiVelX, "VX");
uiVelY = iui_textbox_numberonly(_uix + 100, 64, 80, 24, uiVelY, "VY");
uiVelZ = iui_textbox_numberonly(_uix + 200, 64, 80, 24, uiVelZ, "VZ");
uiVelR = iui_textbox_numberonly(_uix + 300, 64, 80, 24, uiVelR, "VR");

_uix = 500
iui_label(_uix, 20, "STRENGTH", $3e6eef);
uiStrength = iui_textbox_numberonly(_uix, 64, 80, 24, uiStrength, "STR");

_uix = 700
iui_label(_uix, 20, "DITHER", $3e6eef);
uiDither = iui_checkbox(_uix, 64, 24, 24, uiDither, "DITHER");

iui_end();

// set modified values
if (uiVelX != "") velX = real(uiVelX);
if (uiVelY != "") velY = real(uiVelY);
if (uiVelZ != "") velZoom = real(uiVelZ);
if (uiVelR != "") velRot = real(uiVelR);
ditherEnabled = uiDither;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Surface update
time++;

var _cx = surfW * 0.5, _cy = surfH * 0.5;
var surfSrc = surface_create(surfW, surfH); // temp surface
if (!surface_exists(surfResult))
    surfResult = surface_create(surfW, surfH);
if (!surface_exists(surfMotions))
    surfMotions = surface_create(surfW, surfH);

// draw temp source
surface_set_target(surfSrc);
draw_clear(c_red);
draw_background(background0, _cx - background_get_width(background0) * 0.5, _cy - background_get_height(background0) * 0.5);
surface_reset_target();

// motion blur
surface_set_target(surfResult);
draw_clear(c_fuchsia);

// change shaders accordingly
if (ditherEnabled)
{
    // dithering : yes
    shader_set(sh_motionblur);
    
    shader_set_uniform_f(shader_get_uniform(sh_motionblur, "uTexsize"), surfW, surfH); // surface texture size
    shader_set_uniform_f(shader_get_uniform(sh_motionblur, "uNoisesize"), 1 / texture_get_texel_width(noiseTex), 1 / texture_get_texel_height(noiseTex)); // noise texture size
    shader_set_uniform_f(shader_get_uniform(sh_motionblur, "uVelocity"), velX, velY, velZoom, velRot); // camera veloctiy
    shader_set_uniform_f(shader_get_uniform(sh_motionblur, "uStrength"), velStrength, velStrength, velStrength); // blur strength
    shader_set_uniform_f(shader_get_uniform(sh_motionblur, "uTime"), time); // blur strength
    texture_set_stage(shader_get_sampler_index(sh_motionblur, "sNoise"), noiseTex); // noise texture
    
    draw_surface(surfSrc, 0, 0);
    
    shader_reset();
}
else
{
    // dithering : no
    shader_set(sh_motionblur_nodither);
    
    shader_set_uniform_f(shader_get_uniform(sh_motionblur_nodither, "uTexsize"), surfW, surfH); // surface texture size
    shader_set_uniform_f(shader_get_uniform(sh_motionblur_nodither, "uNoisesize"), 1 / texture_get_texel_width(noiseTex), 1 / texture_get_texel_height(noiseTex)); // noise texture size
    shader_set_uniform_f(shader_get_uniform(sh_motionblur_nodither, "uVelocity"), velX, velY, velZoom, velRot); // camera veloctiy
    shader_set_uniform_f(shader_get_uniform(sh_motionblur_nodither, "uStrength"), velStrength, velStrength, velStrength); // blur strength
    shader_set_uniform_f(shader_get_uniform(sh_motionblur_nodither, "uTime"), time); // blur strength
    texture_set_stage(shader_get_sampler_index(sh_motionblur_nodither, "sNoise"), noiseTex); // noise texture
    
    draw_surface(surfSrc, 0, 0);
    
    shader_reset();
}

surface_reset_target();

// motion vector visualization
surface_set_target(surfMotions);
draw_clear(c_fuchsia);
shader_set(sh_motionblur_showmotion);
shader_set_uniform_f(shVecTexSz, surfW, surfH); // surface texture size
shader_set_uniform_f(shVecVel, velX, velY, velZoom, velRot); // camera veloctiy
shader_set_uniform_f(shVecStr, velStrength, velStrength, velStrength); // blur strength
draw_surface(surfSrc, 0, 0);
shader_reset();
surface_reset_target();

// free temp surface
surface_free(surfSrc);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw background &amp; surfaces
var _cx = winW * 0.5, _cy = winH * 0.5;
var _margin = 32;
var _surfx1 = _cx - _margin - surfW;
var _surfx2 = _cx + _margin;
var _surfy = _cy - surfH * 0.5;

draw_clear($131212);
draw_surface(surfResult, _surfx1, _surfy);
draw_surface(surfMotions, _surfx2, _surfy);

// draw motion vector visualization
// TYSM Misumen for buffer_getpixel() :3
var _buf = buffer_getpixel_begin(surfMotions);
var _hdiv = 20;
var _vdiv = 10;
var _hunit = floor((surfW - 1) / _hdiv);
var _vunit = floor((surfH - 1) / _vdiv);
var _2w = surfW * 2 * 0.003921568627451; // w * 2 * (1/255)
var _2h = surfH * 2 * 0.003921568627451;
for (var i=0; i&lt;surfW; i+=_hunit)
{
    var _x = _surfx2 + i;
    for (var j=0; j&lt;surfH; j+=_vunit)
    {
        var _y = _surfy + j;
        
        var _col = buffer_getpixel(_buf, i, j, surfW, surfH);
        var _r = colour_get_red(_col) * _2w - surfW;
        var _g = colour_get_green(_col) * _2h - surfH;
        
        draw_arrow(_x, _y, _x + _r, _y + _g, 6);
    }
}
buffer_delete(_buf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
