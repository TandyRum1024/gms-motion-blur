<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>tex3DPlayer</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-4241</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Physics related variables
mask_index = sprMask16;

z = 4;
vx = 0;
vy = 0;

velocity = 0;

accel = 0.10; //0.06; // vehicle acceleration
accelMax = 9.0;
tractionFactor = 0.05; // vehicle traction force factor
traction = 0.30; // vehicle max traction

totalVel = 0; // vehicle's current velocity magnitude
forwardVel = 0; // vehicle's current forward velocity
sideVel = 0; // vehicle's current forward velocity

rotation = 0; // current rotation
rotationVel = 0; // angular velocity
rotationAccel = 1.5; // rotation speed

// cached sine and cosined vehicle rotation
rotationSin = dsin(rotation);
rotationCos = dcos(rotation);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera shake &amp; animation &amp; misc related variables
camera = noone;
cameraRoataionFactor = 0.1; // camera rotation lerp factor

shaketime = 0;
shakeEnabled = true;
shakeIntensityFactor = 0.5; // intensity factor for each octaves
shakeBaseIntensity = 0.8; // camera shake base intensity
shakeBaseSpeed = 0.02; // camera shake base speed

// animation
time = 0; // time variable for animation
facing = 1; // Mr. T's facing direction
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw related stuff
size = 16;
hypotenuseSize = size / dcos(45);
texIdx = global.textureList[@ ePTEX.PLAYER, 1];

// pivot points of vehicle's rear part
var _sin = dsin(rotation + 45) * hypotenuseSize * 0.8, _cos = dcos(rotation + 45) * hypotenuseSize * 0.8;
buttLX = x - _cos;
buttLY = y - _sin;
buttRX = x - _sin;
buttRY = y + _cos;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Fetch camera object
with (oKNT_3DDEMO)
{
    other.camera = id;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera related stuff
if (camera != noone)
{
    // aim camera towards vehicle
    var _deltarot = -angle_difference(camera.lookH, rotation) * cameraRoataionFactor;
    camera.lookH += _deltarot;
    
    // set camera's position
    var _deltax = camera.x;
    var _deltay = camera.y;
    var _offx = -dcos(rotation) * 80.0;
    var _offy = -dsin(rotation) * 80.0;
    camera.x = lerp(camera.x, x + _offx, 0.08);
    camera.y = lerp(camera.y, y + _offy, 0.08);
    
    // Calculate camera's velocity
    var _sin = dsin(camera.lookH);
    var _cos = dcos(camera.lookH);
    var _sin2 = dsin(camera.lookH + 90);
    var _cos2 = dcos(camera.lookH + 90);
    _deltax = camera.x - _deltax;
    _deltay = camera.y - _deltay;
    
    var _sidevel = dot_product(_cos2, _sin2, _deltax, _deltay) * 0.1;
    var _fwdvel = dot_product(_cos, _sin, _deltax, _deltay);
    
    // apply camera velocity for motion blur
    camera.vfwd = _fwdvel;
    camera.vrh = _deltarot + _sidevel;
    camera.vr += (_deltarot + _sidevel) * 0.22;
    
    // camera shake
    if (shakeEnabled)
    {
        var _vehicleSpeed = min(point_distance(0, 0, vx, vy) * 0.5, 1.0);
        var _shakeSpeed = shakeBaseSpeed * _vehicleSpeed * 10.5;
        
        shaketime += _shakeSpeed;
        var _shakeIntensity = shakeBaseIntensity * _vehicleSpeed;
        
        // make varying octaves of sine to simulate natural shaking
        for (var i=0; i&lt;6; i++)
        {
            var _t = shaketime * (1.0 + i * 0.15) - i * 3.88;
            
            camera.vx += sin(_t + 1.14) * _shakeIntensity;
            camera.vy += cos(_t + 2.14) * _shakeIntensity;
            camera.vz += cos(_t + 3.14) * _shakeIntensity;
            camera.vr += cos(_t * 2.0 + 4.42) * (_shakeIntensity * 0.08);
            _shakeIntensity *= shakeIntensityFactor;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vehicle / hoveboard physics
// inputs
// var _fart = keyboard_check_pressed(vk_space); // DEBUG
var _inputH = keyboard_check(vk_right) - keyboard_check(vk_left);
var _inputV = keyboard_check(vk_up) - keyboard_check(vk_down);

// update rotation
//rotationVel += rotationAccel * _inputH;// * clamp(forwardVel * 0.08 - 0.2, 0.2, 1.0);
rotation += rotationAccel * _inputH;
rotationSin = dsin(rotation);
rotationCos = dcos(rotation);
    
// Update velocity variables
totalVel = point_distance(0, 0, vx, vy); // magnitude of velocity
forwardVel = dot_product(rotationCos, rotationSin, vx, vy) // project x and y velocity onto forward vector to obtain the forward velocity
sideVel = dot_product(-rotationSin, rotationCos, vx, vy); // did some good ol' sine and cosine switcheroo to rotate it 90deg since we need a "side" vector for side velocity

// accelerate
if (_inputV != 0)
{
    var _accelAdd = accel * _inputV;
    _accelAdd = min(accelMax - forwardVel, _accelAdd);
    
    vx += rotationCos * _accelAdd;
    vy += rotationSin * _accelAdd;
    
    // emit pulsating energy effect in order to make it more cyberfunky
    particle3d_impulse_emit(8, 4, buttLX, buttLY, z, vx * 0.5, vy * 0.5, 0);
    particle3d_impulse_emit(8, 4, buttRX, buttRY, z, vx * 0.5, vy * 0.5, 0);
}

// apply traction / side friction
// https://www.youtube.com/watch?v=LG1CtlFRmpU
if (sideVel != 0.0)
{
    var _tractionForce = clamp(sideVel * tractionFactor, -traction, traction);
    var _tractionX = rotationSin * _tractionForce, _tractionY = -rotationCos * _tractionForce;
    
    vx += _tractionX;
    vy += _tractionY;
    
    // drift spark particle
    var _driftForce = point_distance(0, 0, _tractionX, _tractionY);
    if (_driftForce &gt; 0.15 &amp;&amp; random_range(0, traction) &lt; _driftForce)
    {
        particle3d_spark_emit(8, irandom_range(2, 5), buttLX, buttLY, z, _tractionX + random_range(-2, 2), _tractionY + random_range(-2, 2), 8);
        particle3d_spark_emit(8, irandom_range(2, 5), buttRX, buttRY, z, _tractionX + random_range(-2, 2), _tractionY + random_range(-2, 2), 8);
    }
}

if (forwardVel &gt; 5)
{
    particle3d_flash_emit(8, 8, buttLX, buttLY, z, vx * 0.2, vy * 0.2, 0);
    particle3d_flash_emit(8, 8, buttRX, buttRY, z, vx * 0.2, vy * 0.2, 0);
}

// dampen
if (_inputV == 0.0)
{
    vx *= 0.99;
    vy *= 0.99;
}
rotationVel *= 0.9;

// collision check &amp; update position
var _hitVel = 0;

var _sv = sign(vx);
var _off = 0;
if (place_meeting(x + vx, y, oBlock3D))
{
    while (!place_meeting(x + _off + _sv, y, oBlock3D) &amp;&amp; abs(_off) &lt; 33)
        _off += _sv;
    
    // bounce off
    if (_off &lt;= 32)
    {
        _hitVel += abs(vx); // accumulate hit velocity
        
        // solve collision &amp; bounce off
        x += _off
        vx *= -0.5;
    }
}
x += vx;

_sv = sign(vy);
_off = 0;
if (place_meeting(x, y + vy, oBlock3D))
{
    while (!place_meeting(x, y + _off + _sv, oBlock3D) &amp;&amp; abs(_off) &lt; 33)
        _off += _sv;
    
    // bounce off
    if (_off &lt;= 32)
    {
        _hitVel += abs(vy); // accumulate hit velocity
        
        // solve collision &amp; bounce off
        y += _off
        vy *= -0.5;
    }
}
y += vy;

// Update pivot points
var _sin = dsin(rotation + 45) * hypotenuseSize * 0.8, _cos = dcos(rotation + 45) * hypotenuseSize * 0.8;
buttLX = x - _cos;
buttLY = y - _sin;
buttRX = x - _sin;
buttRY = y + _cos;

if (_hitVel &gt;= 0.2)
{
    camera.viewmodelShakeCtr = _hitVel; // Shake the viewmodel

    // emit spark
    particle3d_spark_emit(4 + random_range(-2, 2), irandom_range(8, 12), x + random_range(-2, 2), y + random_range(-2, 2), z + random_range(-2, 2), random_range(-1.0, 1.0), random_range(-1.0, 1.0), random_range(0.1, 0.8));
        
    if (_hitVel &gt;= 4)
    {
        camera.motionblurStrength = 2.0 + _hitVel * 0.2; // make blur strength stronk
        camera.viewmodelShockCtr = 30; // set viewmodel shock counter
        camera.viewmodelShakeCtr += random_range(8, 3 * _hitVel); // Shake the viewmodel
        
        // shake camera
        if (shakeEnabled)
        {
            camera.vx += random_range(-_hitVel, _hitVel) * shakeBaseIntensity;
            camera.vy += (2 + random_range(-1, 3)) * _hitVel * shakeBaseIntensity; //random_range(-_hitVel, _hitVel) * shakeBaseIntensity;
            camera.vz += random_range(-_hitVel, _hitVel) * shakeBaseIntensity;
            camera.vr += random_range(-_hitVel, _hitVel) * shakeBaseIntensity * 1.5;
        }
        
        // emit some particles
        repeat (irandom_range(5, 8))
        {
            particle3d_scrap_emit(16, 64 + irandom_range(-4, 4), x + irandom_range(-8, 8), y + irandom_range(-8, 8), z + irandom_range(2, 4), random_range(-2, 2) + _hitVel * 0.2, random_range(-2, 2) + _hitVel * 0.2, random_range(3, 8) + _hitVel * 0.2);
            particle3d_spark_emit(8 + random_range(-2, 2), irandom_range(30, 60), x + random_range(-2, 2), y + random_range(-2, 2), z + random_range(-2, 2), random_range(-1.0, 1.0), random_range(-1.0, 1.0), random_range(0.1, 0.8));
        }
        
        repeat (floor(_hitVel) + irandom_range(2, 3))
        {
            particle3d_smoke_emit(16 + random_range(-4, 2), irandom_range(8, 24), x + random_range(-16, 16), y + random_range(-16, 16), z + random_range(-16, 16), random_range(-0.5, 0.5), random_range(-0.5, 0.5), random_range(0.1, 0.8));
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update player facing
var _face = dot_product(dcos(camera.lookH), dsin(camera.lookH), -rotationSin, rotationCos);

if (abs(_face) &lt;= 0.08)
{
    facing = 0;
}
else
{
    facing = sign(_face);
}

// update viewmodel
camera.viewmodelFacing = facing;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Barrel collision
mask_index = sprMask32;
var _barrel = instance_place(x, y, oBarrel3D);
if (_barrel != noone)
{
    //_barrel.texIdx = global.textureList[@ ePTEX.BARREL, 1] + 1;
    repeat (irandom_range(3, 6))
    {
        particle3d_smoke_emit(16, 16 + irandom_range(-8, 8), x + irandom_range(-16, 16), y + irandom_range(-16, 16), z + irandom_range(-16, 16), random_range(-4, 4), random_range(-4, 4), random_range(0.1, 6));
    }
    
    repeat (irandom_range(2, 5))
    {
        particle3d_spark_emit(8, 8 + irandom_range(-4, 4), x + irandom_range(-8, 8), y + irandom_range(-8, 8), z + irandom_range(-8, 8), random_range(-16, 16), random_range(-16, 16), random_range(-16, 16));
    }
    
    repeat (irandom_range(4, 8))
    {
        particle3d_scrap_emit(16, 64 + irandom_range(-4, 4), x + irandom_range(-8, 8), y + irandom_range(-8, 8), z + irandom_range(2, 4), random_range(-2, 2), random_range(-2, 2), random_range(6, 12));
    }
    
    instance_destroy(_barrel);
    _barrel = instance_create(x, y, oBarrel3DDead);
    
    _barrel.vx = vx * 0.7 + random_range(-2, 2);
    _barrel.vy = vy * 0.7 + random_range(-2, 2);
    _barrel.vz = 2.5 + forwardVel * 0.1;
    
    // Camera shake
    if (shakeEnabled)
    {
        camera.motionblurStrength = 2.0;
        camera.viewmodelShockCtr = 10; // Set viewmodel shock counter
        camera.viewmodelShakeCtr += random_range(8, 16); // Shake the viewmodel
        camera.vx += random_range(-8, 8) * shakeBaseIntensity;
        camera.vy += random_range(0.8, 2) * shakeBaseIntensity; // random_range(-8, 8) * shakeBaseIntensity;
        camera.vz += random_range(-16, 16) * shakeBaseIntensity;
        camera.vr += random_range(-2, 2) * shakeBaseIntensity;
    }
}
mask_index = sprMask16;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// keep this comment to prevent GM to auto-draw the sprite
/*
var _sz = 16;
var _szThanos = 16;

d3d_transform_stack_push();
d3d_transform_add_rotation_z(-rotation - 90);
d3d_transform_add_translation(x, y, 0);
// Board
d3d_draw_floor(-_sz, -_sz, 0, _sz, _sz, 0, texKdriveShadow, 1, 1);
d3d_draw_floor(-_sz, -_sz, z, _sz, _sz, z, texKdrive, 1, 1);

// TH*NOS
d3d_draw_wall(-_szThanos, 0, z + _szThanos * 2, _szThanos, 0, z, texThanno, 1, 1);
//d3d_draw_wall(-_sz, 0, _sz * 2, _sz, 0, 0, tex2, 1, 1);
d3d_transform_stack_pop();
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
